# java-racingcar-precourse

## 구현할 기능 목록

- **자동차 전진**: 주어진 횟수 동안 n대의 자동차는 전진 또는 멈출 수 있습니다.
- **자동차 이름**: 각 자동차에 이름을 부여할 수 있으며, 전진 시 이름과 함께 출력됩니다.
- **이름 구분**: 자동차 이름은 쉼표(,)로 구분되며, 5자 이하만 가능합니다.
- **사용자 입력**: 사용자는 이동 횟수를 입력할 수 있습니다.
- **전진 조건**: 0에서 9 사이의 무작위 값을 구해 4 이상일 경우 자동차가 전진합니다.
- **우승자 결정**: 게임이 완료되면 우승자를 알려주며, 우승자가 여러 명일 경우 쉼표(,)로 구분합니다.
- **예외 처리**: 잘못된 입력이 발생할 경우 `IllegalArgumentException`이 발생하며 애플리케이션이 종료됩니다.

## 패키지 구조

- **racingcar**
    - **domain**: 데이터 모델을 관리하는 패키지입니다.
        - `Car.java`
        - `CarName.java`
        - `Position.java`
        - `CarCollection.java`
        - `Round.java`
    - **controller**: 게임의 흐름을 제어하는 패키지입니다.
        - `RacingCarController.java`
    - **io**: 입출력 관련 패키지입니다.
        - `Input.java`
        - `Output.java`
        - `InputConsole.java`
        - `OutputConsole.java`
    - **config**: 의존성을 관리하는 패키지입니다.
        - `RacingCarAppConfig.java`

## 게임 로직

- **Application**: 프로그램의 진입점입니다.
- **RacingCarAppConfig**: 의존성 관리 클래스입니다.
- **RacingCarController**: 게임을 제어하는 클래스입니다. 입력을 받고, 게임을 초기화하고, 실행하며, 최종 결과를 출력합니다.
- **CarName**: 입력받은 자동차의 이름인 원시값을 포장하는 클래스입니다.
- **Position**: 자동차의 위치 원시값 포장 클래스입니다.
- **Round**: 입력받은 반복 횟수의 원시값을 포장하는 클래스입니다.
- **CarCollection**: 일급 컬렉션 클래스입니다.
- **Car**: 개별 자동차를 나타내는 클래스입니다. 자동차의 이름과 현재 위치를 포함하고, 전진하는 메서드를 포함합니다.

## 입출력 로직

- **InputConsole**: 사용자로부터 입력을 받는 구현 클래스입니다.
- **OutputConsole**: 게임의 결과를 출력하는 구현 클래스입니다.

## 설명

### 원시값 포장

- **CarName**과 **Position** 클래스는 각각 자동차의 이름과 위치를 포장하여, 유효성 검증과 상태 관리를 해당 클래스에서 책임지도록 했습니다.

### 일급 컬렉션

- **CarCollection** 클래스를 도입하여 모든 자동차의 리스트를 관리하며, 자동차의 이동과 우승자 결정 등의 로직을 한 곳에서 처리했습니다.

### 입출력 분리

- 입출력 인터페이스를 사용하여 콘솔뿐 아니라 다른 형태의 입출력 방식에 대한 확장성을 고려했습니다.
- 게임 로직과 분리되어 하나의 책임만을 담당하도록 설계했습니다.

### Position처럼 입력 받지 않는 원시값을 위해서 포장하는것은 불필요하지 않을까?

- 자동차의 위치라는 의미를 가지고 있다. 경주인 만큼 위치는 중요한 객체이고 불변이어야 한다고 생각한다.
- 중요한 만큼 검증 로직도 필요하다. 위치가 감소하는 로직의 확장 가능성이나 다른 개발자가 이 코드를 봤을때 음수 위치는 유효하지 않다는 의미를 충분히 전달 가능하다고 생각한다.

#### 영문자와 숫자 대시 정도만 입력가능하게 해야함

### 라운드는 int형으로 받는데 포장하는게 낫지 않을까?

- **InputConsole** 클래스에도 검증로직이 들어가있어 단일 책임 원칙에서 벗어나기 때문에 포장하는게 좋을 것 같다.

### 원시값 포장 클래스에 검증 로직이 여기저기 퍼져있다. 포장 클래스의 장점이 단순 검증이 가능하다는건데 어떤 방식이 좀 더 객체지향적이고 가독성이 좋은 코드일까?

- 유틸 클래스를 사용한 검증? 각 객체가 스스로 검증하는게 좋겠지만 검증 로직이 퍼지면 관리가 힘들다. 어디서 검증을 해야할까?
- 각 포장 클래스에서 하게되면 포장클래스가 전부 유틸클래스에 의존하게 되어 좋지 않을것 같다. 뷰 또는 컨트롤러에서 하는게 좋을것 같다.
- 뷰는 단순 입출력만을 하기 때문에 컨트롤러에서 객체를 생성하기 전에 검증을 거치는 것이 좋을것 같다.
- → 컨트롤러의 책임이 증가한다. 객체 생성 시 외부에서 검증하기 때문에 객체의 안전성이 떨어진다.각 객체가 검증 로직을 가지고 있는것이 나을것 같다.
